# -*- coding: utf-8 -*-
"""Optimización por Enjambre de Partículas

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WFmZPdGdE5Yz8CGfrhEIjSjaiI0Dqnsl
"""

import numpy as np
import matplotlib.pyplot as plt

# Definir las funciones objetivo

def griewank(x):
    d = len(x)
    sum_term = np.sum(x**2 / 4000)
    prod_term = np.prod(np.cos(x / np.sqrt(np.arange(1, d + 1))))
    return sum_term - prod_term + 1

def rastrigin(x):
    return 10 * len(x) + np.sum(x**2 - 10 * np.cos(2 * np.pi * x))

def sphere(x):
    return np.sum(x**2)

# Definir la función de optimización por enjambre de partículas (PSO)

def pso(func, bounds, num_particles, max_iter):
    dim = len(bounds)
    # Inicializar las posiciones y velocidades aleatorias
    particles_pos = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_particles, dim))
    particles_vel = np.random.rand(num_particles, dim)
    # Mejor posición local para cada partícula
    personal_best_pos = particles_pos.copy()
    personal_best_val = np.array([func(p) for p in particles_pos])
    # Mejor posición global
    global_best_idx = np.argmin(personal_best_val)
    global_best_val = personal_best_val[global_best_idx]
    global_best_pos = personal_best_pos[global_best_idx].copy()

    # Almacenar la historia de los mejores valores
    history = []

    # Iterar
    for _ in range(max_iter):
        # Actualizar la velocidad y posición de las partículas
        particles_vel = particles_vel + np.random.rand() * (personal_best_pos - particles_pos) + np.random.rand() * (global_best_pos - particles_pos)
        particles_pos = particles_pos + particles_vel

        # Aplicar límites
        particles_pos = np.clip(particles_pos, bounds[:, 0], bounds[:, 1])

        # Calcular el valor de la función objetivo para las nuevas posiciones
        new_vals = np.array([func(p) for p in particles_pos])

        # Actualizar la mejor posición local de cada partícula
        update_idx = new_vals < personal_best_val
        personal_best_pos[update_idx] = particles_pos[update_idx]
        personal_best_val[update_idx] = new_vals[update_idx]

        # Actualizar la mejor posición global
        if np.min(personal_best_val) < global_best_val:
            global_best_idx = np.argmin(personal_best_val)
            global_best_val = personal_best_val[global_best_idx]
            global_best_pos = personal_best_pos[global_best_idx].copy()

        # Guardar la mejor valor global en la historia
        history.append(global_best_val)

    return global_best_pos, global_best_val, history

# Definir los límites y otros parámetros
bounds = np.array([[-5.12, 5.12], [-5.12, 5.12]])  # Límites para Rastrigin y Griewank
num_particles = 30
max_iter = 100

# Ejecutar PSO para cada función y graficar los resultados
functions = [(griewank, "Griewank"), (rastrigin, "Rastrigin"), (sphere, "Sphere")]

for func, name in functions:
    best_pos, best_val, history = pso(func, bounds, num_particles, max_iter)
    print(f"Optimal solution for {name}:")
    print("Best Position:", best_pos)
    print("Best Value:", best_val)

    # Graficar la convergencia
    plt.plot(history, label=name)

plt.title("PSO Convergence")
plt.xlabel("Iteration")
plt.ylabel("Best Value")
plt.legend()
plt.grid(True)
plt.show()